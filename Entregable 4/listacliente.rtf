{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Arial;}}
{\colortbl\red0\green0\blue0;\red255\green255\blue255;\red200\green200\blue200;\red0\green0\blue0;\red160\green160\blue160;\red190\green190\blue230;\red128\green128\blue255;\red0\green128\blue128;\red128\green0\blue0;\red240\green0\blue240;\red240\green200\blue240;\red0\green0\blue160;\red135\green135\blue200;\red0\green160\blue0;\red154\green200\blue154;\red190\green0\blue190;\red190\green137\blue190;\red0\green0\blue255;\red190\green190\blue255;\red224\green160\blue0;\red224\green206\blue159;\red132\green160\blue132;\red255\green0\blue0;\red255\green200\blue200;\red128\green255\blue255;\red64\green64\blue128;\red133\green133\blue172;}
{\info{\comment Generated by the Code::Blocks RTF Exporter plugin}
{\title Untitled}}

\deflang1033\pard\plain\f0\fs24 \cb3\cf13 #include "listacliente.h"
\par #include <iostream>
\par \cb3\cf11\b using namespace \b0\cb3\cf13\b std\b0\cb3\cf22 ;
\par 
\par \cb3\cf11\b void \b0\cb1\cf0 ListaCliente\cb3\cf22 ::\cb1\cf0 intercambiar\cb3\cf22 (\cb1\cf0 NodoCliente\cb3\cf22 *\cb1\cf0 a\cb3\cf22 , \cb1\cf0 NodoCliente\cb3\cf22 *\cb1\cf0 b\cb3\cf22 ) \{
\par     \cb1\cf0 Cliente aux\cb3\cf22 (\cb1\cf0 a\cb3\cf22 ->\cb1\cf0 getCliente\cb3\cf22 ());
\par     \cb1\cf0 a\cb3\cf22 ->\cb1\cf0 setCliente\cb3\cf22 (\cb1\cf0 b\cb3\cf22 ->\cb1\cf0 getCliente\cb3\cf22 ());
\par     \cb1\cf0 b\cb3\cf22 ->\cb1\cf0 setCliente\cb3\cf22 (\cb1\cf0 aux\cb3\cf22 );
\par \}
\par 
\par \cb3\cf11\b void \b0\cb1\cf0 ListaCliente\cb3\cf22 ::\cb1\cf0 copiarTodo\cb3\cf22 (\cb3\cf11\b const \b0\cb1\cf0 ListaCliente\cb3\cf22 &\cb1\cf0 l\cb3\cf22 ) \{
\par     \cb1\cf0 NodoCliente\cb3\cf22 * \cb1\cf0 aux1\cb3\cf22 =\cb1\cf0 l\cb3\cf22 .\cb1\cf0 ultimo\cb3\cf22 ;
\par     \cb1\cf0 NodoCliente\cb3\cf22 * \cb1\cf0 aux2\cb3\cf22 =\cb3\cf11\b nullptr\b0\cb3\cf22 ;
\par 
\par     \cb3\cf11\b while\b0\cb3\cf22 (\cb1\cf0 aux1 \cb3\cf22 != \cb3\cf11\b nullptr\b0\cb3\cf22 ) \{
\par         \cb1\cf0 NodoCliente\cb3\cf22 * \cb1\cf0 nuevoNodo\cb3\cf22 =\cb3\cf11\b new \b0\cb1\cf0 NodoCliente\cb3\cf22 ();
\par         \cb3\cf11\b if\b0\cb3\cf22 (\cb1\cf0 aux2\cb3\cf22 ==\cb3\cf11\b nullptr\b0\cb3\cf22 ) \{
\par             \cb1\cf0 aux2 \cb3\cf22 = \cb1\cf0 nuevoNodo\cb3\cf22 ;
\par             \cb1\cf0 primerInsertado \cb3\cf22 = \cb1\cf0 aux2\cb3\cf22 ;
\par         \}
\par         \cb1\cf0 nuevoNodo\cb3\cf22 ->\cb1\cf0 setCliente\cb3\cf22 (\cb1\cf0 aux1\cb3\cf22 ->\cb1\cf0 getCliente\cb3\cf22 ());
\par         \cb1\cf0 nuevoNodo\cb3\cf22 ->\cb1\cf0 setSiguiente\cb3\cf22 (\cb1\cf0 ultimo\cb3\cf22 );
\par         \cb1\cf0 ultimo \cb3\cf22 = \cb1\cf0 nuevoNodo\cb3\cf22 ;
\par         \cb1\cf0 aux1 \cb3\cf22 = \cb1\cf0 aux1\cb3\cf22 ->\cb1\cf0 getSiguiente\cb3\cf22 ();
\par     \}
\par \}
\par 
\par \cb1\cf0 ListaCliente\cb3\cf22 ::\cb1\cf0 ListaCliente\cb3\cf22 () : \cb1\cf0 ultimo\cb3\cf22 (\cb3\cf11\b nullptr\b0\cb3\cf22 ), \cb1\cf0 auxiliar\cb3\cf22 (\cb3\cf11\b nullptr\b0\cb3\cf22 ), \cb1\cf0 auxiliar2\cb3\cf22 (\cb3\cf11\b nullptr\b0\cb3\cf22 ), \cb1\cf0 primerInsertado\cb3\cf22 (\cb3\cf11\b nullptr\b0\cb3\cf22 ) \{
\par \}
\par 
\par \cb1\cf0 ListaCliente\cb3\cf22 ::\cb1\cf0 ListaCliente\cb3\cf22 (\cb3\cf11\b const \b0\cb1\cf0 ListaCliente\cb3\cf22 &\cb1\cf0 l\cb3\cf22 ) \{
\par     \cb3\cf11\b if\b0\cb3\cf22 (\cb1\cf0 isEmpty\cb3\cf22 ()==\cb3\cf11\b false\b0\cb3\cf22 ) \{
\par         \cb1\cf0 eliminarTodo\cb3\cf22 ();
\par     \}
\par 
\par     \cb1\cf0 copiarTodo\cb3\cf22 (\cb1\cf0 l\cb3\cf22 );
\par \}
\par 
\par \cb1\cf0 ListaCliente\cb3\cf22 ::~\cb1\cf0 ListaCliente\cb3\cf22 () \{
\par     \cb3\cf11\b if\b0\cb3\cf22 (\cb1\cf0 isEmpty\cb3\cf22 () == \cb3\cf11\b false\b0\cb3\cf22 )\{
\par         \cb1\cf0 eliminarTodo\cb3\cf22 ();
\par     \}
\par \}
\par 
\par \cb3\cf11\b bool \b0\cb1\cf0 ListaCliente\cb3\cf22 ::\cb1\cf0 isEmpty\cb3\cf22 () \{
\par     \cb3\cf11\b return \b0\cb1\cf0 ultimo \cb3\cf22 == \cb3\cf11\b nullptr\b0\cb3\cf22 ;
\par \}
\par 
\par \cb3\cf11\b void \b0\cb1\cf0 ListaCliente\cb3\cf22 ::\cb1\cf0 insertar\cb3\cf22 (\cb3\cf11\b const \b0\cb1\cf0 Cliente\cb3\cf22 &\cb1\cf0 c\cb3\cf22 ) \{
\par     \cb1\cf0 NodoCliente\cb3\cf22 * \cb1\cf0 nuevo_nodo \cb3\cf22 = \cb3\cf11\b new \b0\cb1\cf0 NodoCliente\cb3\cf22 (\cb1\cf0 c\cb3\cf22 );
\par     \cb3\cf11\b if \b0\cb3\cf22 (\cb1\cf0 primerInsertado \cb3\cf22 == \cb3\cf11\b nullptr\b0\cb3\cf22 ) \{
\par         \cb1\cf0 primerInsertado \cb3\cf22 = \cb1\cf0 nuevo_nodo\cb3\cf22 ;
\par     \}
\par     \cb1\cf0 nuevo_nodo\cb3\cf22 ->\cb1\cf0 setSiguiente\cb3\cf22 (\cb1\cf0 ultimo\cb3\cf22 );
\par     \cb1\cf0 ultimo \cb3\cf22 = \cb1\cf0 nuevo_nodo\cb3\cf22 ;
\par \}
\par 
\par \cb3\cf11\b void \b0\cb1\cf0 ListaCliente\cb3\cf22 ::\cb1\cf0 eleminar\cb3\cf22 (\cb3\cf11\b const \b0\cb1\cf0 Cliente\cb3\cf22 &\cb1\cf0 c\cb3\cf22 ) \{
\par     \cb3\cf11\b if\b0\cb3\cf22 (\cb1\cf0 isEmpty\cb3\cf22 ()) \{
\par         \cb3\cf11\b throw \b0\cb1\cf0 ListException\cb3\cf22 (\cb3\cf17 "La lista esta vacia,ListaCliente->eliminar"\cb3\cf22 );
\par     \}
\par     \cb1\cf0 auxiliar \cb3\cf22 = \cb1\cf0 ultimo\cb3\cf22 ;
\par     \cb3\cf11\b if\b0\cb3\cf22 (\cb1\cf0 ultimo\cb3\cf22 ->\cb1\cf0 getCliente\cb3\cf22 ()==\cb1\cf0 c\cb3\cf22 ) \{
\par         \cb1\cf0 ultimo\cb3\cf22 =\cb1\cf0 ultimo\cb3\cf22 ->\cb1\cf0 getSiguiente\cb3\cf22 ();
\par         \cb3\cf11\b delete \b0\cb1\cf0 auxiliar\cb3\cf22 ;
\par     \} \cb3\cf11\b else \b0\cb3\cf22 \{
\par         \cb1\cf0 auxiliar \cb3\cf22 = \cb1\cf0 auxiliar\cb3\cf22 ->\cb1\cf0 getSiguiente\cb3\cf22 ();
\par         \cb3\cf11\b while\b0\cb3\cf22 (\cb1\cf0 auxiliar \cb3\cf22 != \cb3\cf11\b nullptr\b0\cb3\cf22 ) \{
\par             \cb3\cf11\b if\b0\cb3\cf22 (\cb1\cf0 auxiliar\cb3\cf22 ->\cb1\cf0 getCliente\cb3\cf22 () == \cb1\cf0 c\cb3\cf22 ) \{
\par                 \cb1\cf0 auxiliar2 \cb3\cf22 = \cb1\cf0 anterior\cb3\cf22 (\cb1\cf0 auxiliar\cb3\cf22 );
\par                 \cb1\cf0 auxiliar2\cb3\cf22 ->\cb1\cf0 setSiguiente\cb3\cf22 (\cb1\cf0 auxiliar\cb3\cf22 ->\cb1\cf0 getSiguiente\cb3\cf22 ());
\par                 \cb3\cf11\b delete \b0\cb1\cf0 auxiliar\cb3\cf22 ;
\par             \}
\par             \cb1\cf0 auxiliar\cb3\cf22 =\cb1\cf0 auxiliar\cb3\cf22 ->\cb1\cf0 getSiguiente\cb3\cf22 ();
\par         \}
\par     \}
\par 
\par 
\par \}
\par 
\par \cb1\cf0 NodoCliente\cb3\cf22 * \cb1\cf0 ListaCliente\cb3\cf22 ::\cb1\cf0 primerNodo\cb3\cf22 () \{
\par     \cb3\cf11\b if\b0\cb3\cf22 (\cb1\cf0 isEmpty\cb3\cf22 ()) \{
\par         \cb3\cf11\b throw \b0\cb1\cf0 ListException\cb3\cf22 (\cb3\cf17 "La lista esta vacia,ListaCliente->primerNodo"\cb3\cf22 );
\par     \}
\par     \cb3\cf11\b return \b0\cb1\cf0 primerInsertado\cb3\cf22 ;
\par \}
\par 
\par \cb1\cf0 NodoCliente\cb3\cf22 * \cb1\cf0 ListaCliente\cb3\cf22 ::\cb1\cf0 ultimoNodo\cb3\cf22 () \{
\par     \cb3\cf11\b if\b0\cb3\cf22 (\cb1\cf0 isEmpty\cb3\cf22 ()) \{
\par         \cb3\cf11\b throw \b0\cb1\cf0 ListException\cb3\cf22 (\cb3\cf17 "La lista esta vacia,ListaCliente->ultimoNodo"\cb3\cf22 );
\par     \}
\par     \cb3\cf11\b return \b0\cb1\cf0 ultimo\cb3\cf22 ;
\par \}
\par 
\par \cb1\cf0 NodoCliente\cb3\cf22 * \cb1\cf0 ListaCliente\cb3\cf22 ::\cb1\cf0 siguiente\cb3\cf22 (\cb1\cf0 NodoCliente\cb3\cf22 *\cb1\cf0 c\cb3\cf22 ) \{
\par     \cb3\cf11\b if\b0\cb3\cf22 (\cb1\cf0 isEmpty\cb3\cf22 ()) \{
\par         \cb3\cf11\b throw \b0\cb1\cf0 ListException\cb3\cf22 (\cb3\cf17 "La lista esta vacia,ListaCliente->siguiente"\cb3\cf22 );
\par     \}
\par     \cb3\cf11\b return \b0\cb1\cf0 c\cb3\cf22 ->\cb1\cf0 getSiguiente\cb3\cf22 ();
\par \}
\par 
\par \cb1\cf0 NodoCliente\cb3\cf22 * \cb1\cf0 ListaCliente\cb3\cf22 ::\cb1\cf0 anterior\cb3\cf22 (\cb1\cf0 NodoCliente\cb3\cf22 *\cb1\cf0 c\cb3\cf22 ) \{
\par     \cb3\cf11\b if\b0\cb3\cf22 (\cb1\cf0 ultimo \cb3\cf22 == \cb1\cf0 c\cb3\cf22 ) \{
\par         \cb3\cf11\b throw \b0\cb1\cf0 ListException\cb3\cf22 (\cb3\cf17 "No hay anterior del ultimo insertado, ListaCliente->anterior"\cb3\cf22 );
\par     \}
\par     \cb1\cf0 auxiliar \cb3\cf22 = \cb1\cf0 ultimo\cb3\cf22 ;
\par     \cb3\cf11\b while\b0\cb3\cf22 (\cb1\cf0 auxiliar \cb3\cf22 != \cb3\cf11\b nullptr\b0\cb3\cf22 ) \{
\par         \cb3\cf11\b if\b0\cb3\cf22 (\cb1\cf0 auxiliar\cb3\cf22 ->\cb1\cf0 getSiguiente\cb3\cf22 () == \cb1\cf0 c\cb3\cf22 ) \{
\par             \cb3\cf11\b return \b0\cb1\cf0 auxiliar\cb3\cf22 ;
\par         \}
\par         \cb1\cf0 auxiliar\cb3\cf22 = \cb1\cf0 auxiliar\cb3\cf22 ->\cb1\cf0 getSiguiente\cb3\cf22 ();
\par     \}
\par 
\par \}
\par 
\par \cb1\cf0 NodoCliente\cb3\cf22 * \cb1\cf0 ListaCliente\cb3\cf22 ::\cb1\cf0 localiza\cb3\cf22 (\cb3\cf11\b const \b0\cb1\cf0 Cliente\cb3\cf22 &\cb1\cf0 c\cb3\cf22 ) \{
\par     \cb3\cf11\b if\b0\cb3\cf22 (\cb1\cf0 isEmpty\cb3\cf22 () == \cb3\cf11\b true\b0\cb3\cf22 ) \{
\par         \cb3\cf11\b throw \b0\cb1\cf0 ListException\cb3\cf22 (\cb3\cf17 "La lista esta vacia,ListaCliente->localiza"\cb3\cf22 );
\par     \}
\par     \cb1\cf0 auxiliar \cb3\cf22 = \cb1\cf0 ultimo\cb3\cf22 ;
\par     \cb3\cf11\b while\b0\cb3\cf22 (\cb1\cf0 auxiliar \cb3\cf22 != \cb3\cf11\b nullptr\b0\cb3\cf22 ) \{
\par         \cb3\cf11\b if\b0\cb3\cf22 (\cb1\cf0 auxiliar\cb3\cf22 ->\cb1\cf0 getCliente\cb3\cf22 () == \cb1\cf0 c\cb3\cf22 ) \{
\par             \cb3\cf11\b return \b0\cb1\cf0 auxiliar\cb3\cf22 ;
\par         \}
\par         \cb1\cf0 auxiliar\cb3\cf22 = \cb1\cf0 auxiliar\cb3\cf22 ->\cb1\cf0 getSiguiente\cb3\cf22 ();
\par     \}
\par     \cb3\cf11\b if\b0\cb3\cf22 (\cb1\cf0 auxiliar \cb3\cf22 == \cb3\cf11\b nullptr\b0\cb3\cf22 ) \{
\par         \cb3\cf11\b throw \b0\cb1\cf0 ListException\cb3\cf22 (\cb3\cf17 "No encontrado,ListaCliente->localiza"\cb3\cf22 );
\par     \}
\par \}
\par 
\par \cb3\cf11\b void \b0\cb1\cf0 ListaCliente\cb3\cf22 ::\cb1\cf0 ordena\cb3\cf22 () \{
\par     \cb3\cf11\b if\b0\cb3\cf22 (\cb1\cf0 isEmpty\cb3\cf22 ()) \{
\par         \cb3\cf11\b throw \b0\cb1\cf0 ListException\cb3\cf22 (\cb3\cf17 "La lista esta vacia, ListaClientes->ordena"\cb3\cf22 );
\par     \}
\par     \cb1\cf0 ordena\cb3\cf22 (\cb1\cf0 ultimo\cb3\cf22 ,\cb1\cf0 primerInsertado\cb3\cf22 );
\par \}
\par 
\par 
\par \cb3\cf11\b void \b0\cb1\cf0 ListaCliente\cb3\cf22 ::\cb1\cf0 ordena\cb3\cf22 (\cb1\cf0 NodoCliente\cb3\cf22 *\cb1\cf0 leftedge\cb3\cf22 , \cb1\cf0 NodoCliente\cb3\cf22 *\cb1\cf0 rightedge\cb3\cf22 ) \{
\par     \cb3\cf11\b if\b0\cb3\cf22 (\cb1\cf0 leftedge \cb3\cf22 == \cb1\cf0 rightedge\cb3\cf22 ) \{
\par         \cb3\cf11\b return\b0\cb3\cf22 ;
\par     \}
\par 
\par     \cb3\cf11\b if\b0\cb3\cf22 (\cb1\cf0 leftedge\cb3\cf22 ->\cb1\cf0 getSiguiente\cb3\cf22 () == \cb1\cf0 rightedge\cb3\cf22 ) \{
\par 
\par         \cb3\cf11\b if\b0\cb3\cf22 (\cb1\cf0 leftedge\cb3\cf22 ->\cb1\cf0 getCliente\cb3\cf22 () > \cb1\cf0 rightedge\cb3\cf22 ->\cb1\cf0 getCliente\cb3\cf22 ()) \{
\par 
\par             \cb1\cf0 intercambiar\cb3\cf22 (\cb1\cf0 leftedge\cb3\cf22 , \cb1\cf0 rightedge\cb3\cf22 );
\par 
\par         \}
\par         \cb3\cf11\b return\b0\cb3\cf22 ;
\par     \}
\par 
\par     \cb1\cf0 NodoCliente\cb3\cf22 * \cb1\cf0 i\cb3\cf22 (\cb1\cf0 leftedge\cb3\cf22 );
\par     \cb1\cf0 NodoCliente\cb3\cf22 * \cb1\cf0 j\cb3\cf22 (\cb1\cf0 rightedge\cb3\cf22 );
\par 
\par     \cb3\cf11\b while\b0\cb3\cf22 (\cb1\cf0 i \cb3\cf22 != \cb1\cf0 j\cb3\cf22 ) \{
\par         \cb3\cf11\b while\b0\cb3\cf22 (\cb1\cf0 i \cb3\cf22 != \cb1\cf0 j and i\cb3\cf22 ->\cb1\cf0 getCliente\cb3\cf22 () <= \cb1\cf0 rightedge\cb3\cf22 ->\cb1\cf0 getCliente\cb3\cf22 ()) \{
\par             \cb1\cf0 i \cb3\cf22 = \cb1\cf0 i\cb3\cf22 ->\cb1\cf0 getSiguiente\cb3\cf22 ();
\par         \}
\par 
\par         \cb3\cf11\b while\b0\cb3\cf22 (\cb1\cf0 i \cb3\cf22 != \cb1\cf0 j and j\cb3\cf22 ->\cb1\cf0 getCliente\cb3\cf22 () >= \cb1\cf0 rightedge\cb3\cf22 ->\cb1\cf0 getCliente\cb3\cf22 ()) \{
\par             \cb1\cf0 j \cb3\cf22 = \cb1\cf0 anterior\cb3\cf22 (\cb1\cf0 j\cb3\cf22 );
\par         \}
\par 
\par         \cb1\cf0 intercambiar\cb3\cf22 (\cb1\cf0 i\cb3\cf22 , \cb1\cf0 j\cb3\cf22 );
\par     \}
\par     \cb1\cf0 intercambiar\cb3\cf22 (\cb1\cf0 i\cb3\cf22 , \cb1\cf0 rightedge\cb3\cf22 );
\par 
\par     \cb1\cf0 if( i!= leftedge) \{
\par         ordena(leftedge, anterior(i));
\par     \}
\par 
\par     if(i != rightedge) \{
\par         ordena(i->getSiguiente(), rightedge);
\par     \}
\par 
\par \}
\par 
\par string ListaCliente::recupera(const Cliente&c) \{
\par     auxiliar = ultimo;
\par     while(auxiliar != nullptr) \{
\par         if(auxiliar->getCliente() == c) \{
\par             Cliente aux(auxiliar->getCliente());
\par             return aux.toString();
\par         \}
\par         auxiliar = auxiliar->getSiguiente();
\par     \}
\par     throw ListException("No encontrado,ListaCliente->recupera");
\par \}
\par 
\par string ListaCliente::toString() \{
\par     string resultado;
\par     if(isEmpty()) \{
\par         resultado = "La lista esta vacia";
\par         return resultado;
\par     \}
\par 
\par     auxiliar = ultimo;
\par     while(auxiliar != nullptr) \{
\par         resultado += auxiliar->toString();
\par         resultado += "\\n";
\par         auxiliar = auxiliar->getSiguiente();
\par     \}
\par     return resultado;
\par \}
\par 
\par void ListaCliente::guardarAlDisco(const string& fileName) \{
\par     ofstream myFile;
\par     myFile.open("Archivos\\\\" + fileName, myFile.trunc);
\par 
\par     if(! myFile.is_open()) \{
\par         string message;
\par         message = "Error al tratar de abrir el archivo ";
\par         message += fileName;
\par         message += " para escritura";
\par         throw ListException(message);
\par     \}
\par     NodoCliente* aux(ultimo);
\par     while(aux != nullptr) \{
\par         myFile << aux->getCliente() << endl;
\par         aux = aux->getSiguiente();
\par     \}
\par     myFile.close();
\par \}
\par 
\par void ListaCliente::leerDelDisco(const string& fileName) \{
\par     ifstream myFile;
\par 
\par     myFile.open("Archivos\\\\" + fileName);
\par 
\par     if(!myFile.is_open()) \{
\par         string message;
\par         message = "Error al tratar de abrir el archivo";
\par         message+= fileName;
\par         message+= "para escritura";
\par         throw ListException(message);
\par     \}
\par     if(isEmpty() == false) \{
\par         eliminarTodo();
\par     \}
\par 
\par     Cliente myCliente;
\par 
\par     while(myFile >> myCliente) \{
\par         insertar(myCliente);
\par     \}
\par 
\par     myFile.close();
\par \}
\par 
\par 
\par void ListaCliente::eliminarTodo() \{
\par     if(isEmpty()) \{
\par         throw ListException("La lista esta vacia,ListaCliente->eliminarTodo");
\par     \}
\par     auxiliar = ultimo;
\par     while(auxiliar != nullptr) \{
\par         auxiliar2 = auxiliar;
\par         auxiliar = auxiliar->getSiguiente();
\par         delete auxiliar2;
\par     \}
\par     ultimo = nullptr;
\par     primerInsertado = nullptr;
\par \}
\par 
\par ListaCliente& ListaCliente::operator=(const ListaCliente&l) \{
\par     if(isEmpty()==false) \{
\par         eliminarTodo();
\par     \}
\par     copiarTodo(l);
\par     return *this;
\par \}
\par }